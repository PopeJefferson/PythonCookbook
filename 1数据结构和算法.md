# 数据结构和算法



## 1.1 将序列分解为单独的变量

将一个包含N个元素的远足或序列, 将其分解为N个单独的变量

```python
# 任何(可迭代对象)都可以通过一个简单的复制操作来分解为单独的变量.
# 要求: 变量的总数和结构要与系列相吻合, 如果元素的数量不匹配, 会得到一个错误提示.
p = (4, 5)
x, y = p
print(x, y)

data = ['ACME', 50, 91.1, (2012, 12, 20)]
name, shares, price, date = data
name, shares, price, (years, month, day) = data
print(name, shares, price, years, month, day)

s = 'Hello'
a, b, c, d, e = s
print(a, b, c, d, e)

# 对于需要丢弃的值, 通常选用一个用不到的变量名作为要丢弃值得名称.
_, shares, price, _ = data
print(shares, price, _)
```

```python
4 5
ACME 50 91.1 2012 12 20
H e l l o
50 91.1 (2012, 12, 20)
```



## 1.2 从任意长度的可迭代对象中分解元素

- 需要从某个可迭代对象中分解出N个元素, 但是这个可迭代对象的长的可能超过N, 这会导致出现 "分解的值过多(too many values to unpack)" 的异常. python中的 "*"表达式可以用来解决这个问题,.

  ```python
  # 例: 假设有一些用户记录记录由姓名和电子邮件地址组成, 后面跟着任意数量的电话号码. 则可以这样分解记录:
  # 不管需要分解出多少个电话号码(甚至没有电话号码), 变量phone_numbers一直都是列表.
  record = ('Dave', 'dave@example.com', '773-555-1212', '847-555-1212')
  name, email, *phone_numbers = record
  print(name, email, phone_numbers)
  ```

  ```python
  Dave dave@example.com ['773-555-1212', '847-555-1212']
  ```

- 由*修饰的变量也可以位于列表的第一个位置. 

  ```python
  *trailing, current = [10, 8, 7, 1, 9, 5, 10, 3]
  print(trailing)
  print(current)
  ```

  ```python
  [10, 8, 7, 9, 5, 10]
  3
  ```

- *式的语法在迭代一个变长的远足序列时尤其有用.

  ```python
  # 例: 假设有一个代表及的元祖序列
  records = [
      ('foo', 1, 2),
      ('bar', 'hello'),
      ('foo', 3, 4),
  ]
  
  def do_foo(x, y):
      print('bar', x, y)
      
  def do_bar(s):
      print('bar', s)
  
  for tag, *args in records:
      if tag == 'foo':
          do_foo(*args)
      elif tag == 'bar':
          do_bar(*args)
  ```

  ```python
  bar 1 2
  bar hello
  bar 3 4
  ```

  

## 1.3保存最后N个元素

保存有限的历史纪录是collections.deque的完美应用场景. 例:

```python
# 对一系列文本进行简单的文本匹配操作, 当发现没有匹配时就输出当前匹配行以及最后检查过的N行文本
from collections import deque

def search(lines, pattern, history=5):
    previous_lines = deque(maxlen=history)
    for line in lines:
        if pattern in line:
            yield line, previous_lines
        previous_lines.append(line0)

if __name__ == '__main__':
    with open('somefile.txt') as f:
        for line, prevlines in search(f, 'python', 5):
            for pline in prevlines:
                print(pline, end='')
            print(line, end='')
            print('-'*20)
```

- deque(maxlen=N)创建了一个固定长度的队列. 当有新纪录加入而队列已满时会自动移除最老的那条记录. 例如:

  ```python
  from collections import deque
  
  q = deque(maxlen=3)
  q.append(1)
  q.append(2)
  q.append(3)
  print(q)
  q.append(4)
  print(q)
  q.append(5)
  print(q)
  ```

  ```python
  deque([1, 2, 3], maxlen=3)
  deque([2, 3, 4], maxlen=3)
  deque([3, 4, 5], maxlen=3)
  ```

- 如果不指定大小, 就得到了一个无界限的队列, 可以在两端执行添加和弹出操作, 例如:

  ```python
  from collections import deque
  
  q = deque()
  q.append(1)
  q.append(2)
  q.append(3)
  print(q)
  q.appendleft(4)
  print(q)
  print(q.pop())
  print(q)
  print(q.popleft())
  print(q)
  ```

  ```python
  deque([1, 2, 3])
  deque([4, 1, 2, 3])
  3
  deque([4, 1, 2])
  4
  deque([1, 2])
  ```

  注意: 从队列两端添加或弹出元素的复杂度都是O(1). 这和列表不同, 当从列表的头部插入或者移除元素时, 列表的复杂度为O(N).

  

## 1.4 找到最大或最小的N个元素

heapq模块中有两个函数---nlargest()和nsmallest()

```python
import heapq

nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]
print(heapq.nlargest(3, nums))
print(heapq.nsmallest(3, nums))
```

```python
[42, 37, 23]
[-4, 1, 2]
```

- 这两个函数都可以接受一个参数key, 从而允许它们工作在更加复杂的数据结构之上. 例如;

  ```python
  import heapq
  
  portfolio = [
      {'name': 'IBM', 'shares': 100, 'price': 91.1},
      {'name': 'AAPL', 'shares': 50, 'price': 543.22},
      {'name': 'FB', 'shares': 200, 'price': 21.09},
      {'name': 'HPQ', 'shares': 35, 'price': 31.75},
      {'name': 'YHOO', 'shares': 16.35, 'price': 16.35},
      {'name': 'ACME', 'shares': 75, 'price': 115.65},
  ]
  
  cheap = heapq.nsmallest(3, portfolio, key=lambda s: s['price'])
  expensive = heapq.nlargest(3, portfolio, key=lambda s:['price'])
  print(cheap)
  print(expensive)
  ```

  ```python
  [{'name': 'YHOO', 'shares': 16.35, 'price': 16.35}, {'name': 'FB', 'shares': 200, 'price': 21.09}, {'name': 'HPQ', 'shares': 35, 'price': 31.75}]
  [{'name': 'IBM', 'shares': 100, 'price': 91.1}, {'name': 'AAPL', 'shares': 50, 'price': 543.22}, {'name': 'FB', 'shares': 200, 'price': 21.09}]
  ```


- 如果正在寻找最大或者最小的N个元素, 且统计和中元素怒的总数目相比, N很小, 那么下面这些函数可以提供更好的性能. 这些函数首先会在底层将数据转化成列表, 且元素会以堆的顺序排序. 例如:

  ```python
  import heapq
  
  nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]
  heap = list(nums)
  heapq.heapify(heap)
  print(heap)
  ```

  ```python
  [-4, 2, 1, 23, 7, 2, 18, 23, 42, 37, 8]
  ```

- 堆最重要的特征就是heap[0]总是最小的那个元素. 此外, 接下来的元素可依次通过heapq.heappop()方法轻松找到. 该方法会将第一个元素(最小的)弹出, 然后以第二小的元素取而代之(这个操作的复杂度时O(logN), N代表堆的大小). 例如,   要找到第3小的元素, 可以这样

  ```python
  print(heapq.heappop(heap))
  print(heapq.heappop(heap))
  print(heapq.heappop(heap))
  ```

当所要找的元素数量相对较小时, 函数nlargest()和nsmallest()才是最实用的. 如果只是简单地想找最小或者最大的元素(N=1)时, 那么min()和max()会更加快. 同样, 如果N和集合本身的大小差不多大, 通常更快的方法时堆集合排序, 然后做切片操作(例如: 使用 sorted(items)[:N]或者 sorted(items)[-N]). 应该注意的是, nlargest()和nsmallest()的实际实现会更具它们的方式而有所不同, 可能会相应做出一些优化措施(比如, 当N的大小同输入大小很接近时, 就会采用排序的方法).



## 1.5 实现优先级队列

我们想要实现一个队列, 他能够以给定的优先级来对元素排序, 且每次pop操作时会返回优先级最高的那个元素.

下面的类利用heapq模块实现了一个简单的优先级队列:

```python
import heapq

class PriorityQueue:
    
    def __init__(self):
        self._queue = []
        self._index = 0
        
    def push(self, item, priority):
        heapq.heappush(self._queue, (-priority, self._index, item))
        self._index += 1
       
    def pop(self):
        return heapq.heappop(self._queue)[-1]
    
class Item:
    
    def __init__(self, name):
        self.name = name
       
    def __repr__(self):
        return 'Item({!r})'.format(self.name)
   
q = PriorityQueue()
q.push(Item('foo'), 1)
q.push(Item('bar'), 5)
q.push(Item('spam'), 4)
q.push(Item('grok'), 1)
print(q.pop())
print(q.pop())
print(q.pop())
print(q.pop())
    
```

```python
Item('bar')
Item('spam')
Item('foo')
Item('grok')
```

注意观察, 第一次执行pop()操作时返回的元素具有最高的优先级. 我们也观察到拥有相同优先级的两个元素(foo和grok)返回的顺序同他们插入到队列时的顺序相同.

heapq.heappush()函数说明: 第一个参数为操作的序列, 第二个参数为一个元元组, 通过使用<运算符比较元组中的元素大小来判断插入的位置, 如果第一个元素相同则比较下一个元素, 以此类推, 直到元组中的最后一个元素.

上面的代码片段的核心在于heapq模块的使用. 函数heapq.heappush()以及heapq.heappop()分别实现将元素从列表_queue中插入和移除, 且保证列表中第一个元素的优先级最低. heappop()方法总是返回"最小"的元素, 因此这就是让队列能弹出正确元素的关键. 此外, 由于push和pop操作的复杂度都是O(logN),, 其中N代表堆中元素的数量, 因此就算N中的值很大, 这些操作的效率也非常高.

在这段代码中, 队列以元组(-priority, index, item)的形式组成. 把priority取负值是为了让队列能够暗元素的优先级从高到低的顺序排序. 这和正常的堆排列顺序相反, 一般情况下堆时按从小到大的顺序排序的.

变量index的作用是为了将具有相同优先级的元素以适当的顺序排列. 通过维护一个不断递增的索引, 元素将以他们入队列时的顺序来排序 但是, index在对具有相同优先级的元素作比较操作时同样扮演了重要的角色, 而Item实例是没法进行次序比较的.

















